# -*- coding: utf-8 -*-
"""Copy of Vehicle Routing Problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zWdgYJYSlByVouaacpzA3lWiGzhEdwIR
"""

#TASK 1 - Install matplotlib and deap
!pip install matplotlib deap
#  - Import all necessary libraries

# TODO: Task 2 - Define the number of locations and vehicles

num_locations = 10
import random

locations = [(random.randint(0,100),random.randint(0,100)) for i in range (num_locations)]
# Create a list of tuples representing location coordinates -
# try to use a random number generator
# (x, y) could be between 0 and 100

depot = (50,50)
# Define the coordinates for the depot
#starting and ending part of v
num_vehicles = 3
# Define the number of vehicles - (eg 3)

# TASK 3 - Genetic Algorithm Setup
       # - Figure out how to represent an individual OR encode an individual
from deap import base, creator
creator.create("FitnessMin",base.Fitness,weights=(-1.0,-1.0))#we want lowest value
creator.create("Individual", list,fitness=creator.FitnessMin)#class

#TASK 4 - Starting with the toolbox and tools
from deap import base, creator, tools, algorithms
toolbox = base.Toolbox()
toolbox.register("indices", random.sample, range(num_locations), num_locations)
toolbox.register("individual",tools.initIterate, creator.Individual, toolbox.indices)
toolbox.register("population", tools.initRepeat, list,toolbox.individual)

# TASK 5 and 6
import numpy as np

def evalVRP(individual):
    total_distance = 0
    distances = []  # Track distance traveled by each vehicle for balance calculation

    # Split the list of locations among vehicles, ensuring each starts and ends at the depot
    for i in range(num_vehicles):
        # Construct the route for this vehicle
        vehicle_route = [depot] + [locations[individual[j]] for j in range(i, len(individual), num_vehicles)] + [depot]

        # Calculate total distance traveled by this vehicle
        vehicle_distance = 0
        for k in range(len(vehicle_route) - 1):
            loc1=vehicle_route[k]
            loc2=vehicle_route[k+1]
            vehicle_distance += np.sqrt((loc1[0]-loc2[0])**2+(loc1[1]-loc2[1])**2)
            #mean variance standard dev for the total diatance is long

        # Add to total distance and store this vehicle's distance
        total_distance += vehicle_distance
        distances.append(vehicle_distance)

    # Calculate the balance penalty using standard deviation of distances
    balance_penalty = np.std(distances)  # Penalize imbalance among vehicles

    return total_distance, balance_penalty

# Register the evaluation function to the toolbox
toolbox.register("evaluate", evalVRP)

    # TODO: Task 5 - Write the fitness evaluation function
    #              - Return (total distance, standard deviation)
#TASK 6 - Register the evaluate function in the toolbox

# TODO: Task 7 - Configure the genetic operators

toolbox.register("mate", tools.cxPartialyMatched)
toolbox.register("mutate", tools.mutShuffleIndexes,indpb=0.2)
toolbox.register("select", tools.selTournament,tournsize=3)

import matplotlib.pyplot as plt
def plot_routes(individual, title="Routes"):
        plt.scatter(depot[0], depot[1], marker='s', color='black', s=100, label='Depot')
        plt.scatter([loc[0] for loc in locations], [loc[1] for loc in locations], marker='o', color='blue', s=50, label='Locations')
        for i in range(num_vehicles):
            vehicle_route = [depot] + [locations[individual[j]] for j in range(i, len(individual), num_vehicles)] + [depot]
            x_coords = [loc[0] for loc in vehicle_route]
            y_coords = [loc[1] for loc in vehicle_route]
            plt.plot(x_coords, y_coords, marker='o', linestyle='-', label=f'Vehicle {i+1}')
        plt.xlabel('X-coordinate')
        plt.ylabel('Y-coordinate')
        plt.title(title)
        plt.show()
plot_routes([0,2,4,3,1,2,3,4,6])

# SOLUTION - TASK 8
def plot_routes(individual, title="Routes"):
    plt.figure()
    # Plot locations as blue dots and the depot as a red square
    for (x, y) in locations:
        plt.plot(x, y, 'bo')
    plt.plot(depot[0], depot[1], 'rs')

    # Draw routes for each vehicle
    for i in range(num_vehicles):
        vehicle_route = [depot] + [locations[individual[j]] for j in range(i, len(individual), num_vehicles)] + [depot]
        plt.plot(*zip(*vehicle_route), '-', 'rs')

    plt.title(title)
    plt.xlabel('X Coordinate')
    plt.ylabel('Y Coordinate')
    plt.show()

# Running the Genetic Algorithm
# Running the Genetic Algorithm
def main():
    random.seed(42)  # Seed for reproducibility
    pop = toolbox.population(n=300)  # Generate initial population
    hof = tools.HallOfFame(1)  # Hall of Fame to store the best individual

    # Setup statistics to track
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean)
    stats.register("min", np.min)

    # Run the genetic algorithm
    algorithms.eaSimple(pop, toolbox, 0.7, 0.2, 300, stats=stats, halloffame=hof)

    # Plot the best route found
    plot_routes(hof[0], "Optimal Route")
    return pop, stats, hof

if __name__ == "__main__":
    # TODO: Task 9 - Call the main function, run the algorithm and print the results
    main()

